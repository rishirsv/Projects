# YouTube Transcript
Video ID: 6TMPWvPG5GA
Title: The "right way" to vibe code (engineers, please watch)
Extracted: 2025-09-27T01:40:05.192Z
Length: 36491 characters

---

What's the point of vibe coding if I still have to pay a dev to fix it? What's the point if at the end of the day I've still got to pay a dev to look at the code anyways? Sure, it feels kind of cool while I'm typing, like I'm in some flow state or whatever, but when stuff breaks, it's just dead weight. I can't vibe my way through debugging. I can't ship anything that actually matters, and then I'm back to square one, pulling out my wallet for someone who actually knows what they're doing. It makes me think that vibe coding is just roleplay for guys who want to feel like hackers without doing the hard part. Am I missing something here or is it really just useless once you step outside of the fantasy? As soon as I saw this post, I knew I was going to have to talk about it. First, I would like to respond to the author. He asked, "Is he missing something here or does this just fall apart when you leave the fantasy?" I don't think he's missing anything in terms of what vibe coding is and what it's capable of, but I do think he's missing some pieces that help the whole puzzle come together much better. I feel like a lot of people talk about this stuff in a way that's, to be frank, not great. Most of the conversation I see about vibe coding is either vibe coding is going to replace engineers or vibe coding is a joke and no one's actually using it for anything. And I find that reality is somewhere between the two in ways that are hard to describe and go into detail about. But talking about things that are hard to talk about has never really stopped me, has it? Especially if it means people are going to be pissed off on both sides. I'm very good at pissing people off on both sides, as I've learned over the years. So, I guess it's time to break down where vibe coding is actually good and why people continuously use it the wrong way. While under this lens, vibe coding might seem pointless, it definitely does have a point. The point isn't to replace engineers. It's to replace engineering, and that is a very valuable thing for it to do. I'm excited to explain what I mean, but sadly, I can't vibe video edit just yet. So, I got to pay my team. So, quick word from today's sponsor to cover the bills and then we'll dive in. Thanks to AI, my team's been writing way more code recently. But that means I have to review way more code, too. which is why today's sponsor has been coming in clutch. Code Rabbit is saving our butts with code review. I cannot tell you how many bugs they have kept me from shipping. The thing that makes Code Rabbit different is that it learns your codebase. Not like it throws it all in context and magically knows everything, but over time as you tell it things, it remembers them. So when I tell it, hey, we don't care about that or make sure you note this in the future, it will do it. It's like if your lint rules were receptive to feedback during code review. if you just left a comment and now your code's being linted with that in mind and it's so cool. This is a really good example here because it requires an understanding of our codebase and of multiple different services as well as of effect. This is not an easy thing for it to leave feedback on. I would not have caught these mistakes. Here we have attachment IDs for generation of images by Gemini. If we have an attachment then we'll reference it using the UFS URL which is the URL pointing to that file from upload thing. But they recommend that we guard against missing keys and drop the non-null assertions, which yeah, we probably should. This exclamation point is very scary. The fact that it noticed that this is code that is running through convex and might have a bad case there too is huge. It deeply understands how these pieces come together and gives actual useful feedback and a prompt that I can copy paste into whatever coding tools I use to go solve this bug for me. They even have a commitable section where I can oneclick commit the change. One of my small favorite things that I really like is the estimated code review effort. It lets me know going in how much time should I expect to spend on this thing. The VS Code extension is great, too. Reviewing the code before it even leaves your machine. I found that to be very useful for not wasting my team's time. It's free to get started. It's super cheap. It'll make you less annoying to your teammates. And it's fully free for open source projects. It's a pretty hard deal to beat if you ask me. Check them out today at soyv.link/codrabbit. Before we can figure out what the point of vibe coding is, we probably need a definition of vibe coding. The problem is there's a lot of different definitions of vibe coding. For some people, vibe coding means doing most of the work via plain English, as in they don't write code. They just prompt via the sidebar. For some people, it means ignoring the code entirely and only prompting. And for some people it means non-developers writing code via AI. And then for some people it means using autocomplete in their ID. These are all incompatible definitions. These things don't have any overlap at all in my mind. And this is very very annoying when trying to talk about vibe coding because as soon as I say the term vibe coding, everyone who hears me talking assumes I'm talking about whichever of the definitions they go with. And if I'm talking about this part, ignoring the code entirely and only prompting, and they're talking about autocomplete in their editor, and I say vibe coding is a waste and they think vibe coding is useful because they think vibe coding is tab complete, entirely different. If we don't agree on these terms, we cannot have a conversation. Which is why the sheer existence of a vibe coding subreddit is inherently problematic because every person who goes to this subreddit is using a different [ __ ] definition. I already see people saying that the first two seem like the same thing. You are so [ __ ] wrong. It hurts me. I'm going to label these so that we can better explain them. So, A, B, C, and D. I know it seems subtle, but the word most here is very important. Not because what is or isn't most of your work matters, but because the implication of most is that some work isn't done via prompting, which means you are paying attention to the code at all. That's the key here that you need to understand. You can kind of see this as a spectrum of how well people understand code. Let's make this into my favorite thing, an axis. multi-dimensional, which I'm sure won't confuse anyone. On the right here, we'll say leak code killer. This is like the debiest of developers, the people who won't leave Neoim unless you pay them a lot of money to do it. And even then, they'll use it on the side. And here we have what's a computer? These are people who have who primarily operate the world via their iPhones. They don't really understand how files work, if they understand them at all. And coding is not a thing they'll ever do. And then we have this vertical spectrum which is how much are you looking at the code. My life is get diffs is the top and wait you read this [ __ ] is the bottom. This is a spectrum and most people's definition of vibe code goes somewhere here and the four examples I gave here are meant to cover that range. So if I take this and put it here we have A, B, C and D. A, which is doing most of the work via plain English. We don't really know where they fall, but we do. They fall on the right side here. They're absolutely a real developer because they couldn't do any work without prompting if they weren't, but they are reading it. So, I would say that squarely falls in this section. Ignoring the code entirely and only prompting goes here, bottom right. You're not reading the code, but you do know how to code. So, if things do go wrong, you can fix it, but you're probably just going to throw it away and actually write it at that point. There's non-devs writing code via AI. That's this section. And then people using autocomplete in their IDEs. That's like even further up here where they're reading the code every step along the way. What's a computer and my life is git diffs. This section I call this boot camps. Okay. Actually though, there's nothing in this section legitimately. The point here is to show where [ __ ] falls. And the author of the post that inspired this video seems to very squarely fall in this area here where they don't know how to code and they don't read the code. Those people are kind of screwed because they cannot get by without knowing how the code works. And that's the harshest reality that we should hopefully all agree on getting started. You still need to know how code works if you want to be a coder. I hope this isn't a controversial take. The problem with vibe coding is that it was invented by engineers for engineers as the concept of this area here, section B. And I also understand that the majority of people watching this probably don't like this section and probably haven't had good experiences here. This is the harshest reality. We spend so much time in the developer world fighting about the difference between these two which again are A which is doing most of the code via prompting and D which is autocomplete. We fight over the distinction here so much that the much more interesting distinction which is between these two gets ignored entirely. As you all know I use cursor. Yes, I'm an investor. No, that doesn't mean I always like them and shill them. I churned from cursor multiple times and didn't use them for years before I caved and started using them. There's a couple different ways to use cursor. The main two are the tab complete which I love. I really really like the tab completing cursor. Even people who hate vibe coding stuff like you know primogen love the tab completing cursor. It's really really good. The other way to use it is the agent mode which is this bar on the left side here. It will be on the right for most people. I shift them because I want you to be able to read this part when I'm talking about it. My face would cover it otherwise. This section falls a lot more in the vibe coding world where you tell it a description of what you want and then it uses tools to read files in the codebase, look things up online and make changes to suggest the code that will solve your problem. This is agentic coding which often is mistaken for vibe coding. But the difference between agentic coding and vibe coding is that vibe coding is a subset. Agentic coding is using prompts that use tools to then generate code. Vibe coding is when you don't read the code after. And here is where I will drop my definition of vibe coding. Vibe coding is everything below the bar. Vibe coding is when you're not really reading the code very much and you're more likely to copy paste the error message into the text box than you are to go and read the code directly. And here's the thing that many people have not yet accepted in the developer world. This is a good place to be. this area where sometimes you let tab complete help you out, sometimes you use the agentic flows and just review all of the code actively and sometimes you just don't [ __ ] care. The harsh reality is that the majority of code we write is throwaway code. You might not accept that, but it's true. For every line of code that ships to production, many more get written and deleted. Many more never see the light of day at all. Scripts are written to help you with random [ __ ] one-off things are being done in your terminal or inside of like crazy stuff like the inspector in the browser. I've written so much code in the Chrome and now Firefox console that is not real code and now I don't even look at the code cuz I'll go do it on T3 chat, generate a JavaScript like quick function that will do what I'm looking for, paste it, run it and if it doesn't work I go back to T3 chat and say hey this didn't work. So let's do my list of truths. Truth one, you still need to know how code works if you want to be a coder. Truth two, there's a lot of code worth having that is not worth writing or reading. This is the part I find a lot of developers miss. They have this emotional attachment to the code they write and they refuse to accept the fact that a lot of code that could be beneficial to them isn't worth the time to sit there and write. I run into this a lot. I have a lot of random things that don't exist that I wish existed. and I could sit there for a week and build it or I could sit there for an hour and have it. That's what vibe coding is great for. It's throwaway code. It's legacy code. It's [ __ ] that you don't want to deal with. The reason you're not looking at the code isn't because you don't know how. It's because it's not worth looking at because it's not worth writing. I've built a bunch of benchmarks for AI models. It's really fun to do and it helps me make better content about the models that I'm talking about. that would not have been worth me spending days if not weeks to build the tooling up to make those benchmarks viable. That said, when I use Vibe coding solutions and I go hang out in cursor, I can generate a lot of the code that I need and then not read it and have it work. I have not read the majority of the logic code, especially the UI side for skatebench. I don't actually know how that part works. I explained what I wanted to do. I had a working core prototype that would run the test because the test runner is the simple part. That's like 50 lines of code that I actually paid a little bit of attention to the first time I wrote it. Now it just gets copy pasted and generated from that point forward. The rest is UI boilerplate scaffolding and [ __ ] And vibe coding lets me not look at those details and just ship the thing. And if you look at other benchmarks from more traditional research people, the code I vibe coded is better than the code they actually wrote in Python. I have run far too many benchmarks to even pretend otherwise. The [ __ ] I'm generating with cursor combined with my own opinions and taste here and there comes out better than a lot of the slot people are shipping in production every day. There's another point someone just made in chat that I want to go in on because I couldn't agree more. Number two, which is the thing I just said about there's a lot of code that's not worth writing, is why that people use so many random packages in their React apps. I'm going to go a step further with that. You can't be mad at Vibe coding and be mad at Leftpad. That's contradictory. You cannot be mad about the fact that people are installing solutions to their problems. They then be more mad when they have a tool that will write it for them instead. Apparently, people don't know about Leftpad anymore. That's crazy. I feel old. Tag's been deprecated. Use string prototype pad start. Leftpad is a package that lets you add spaces in front of a string. Writing this is like three lines of code and now it's built into JavaScript. This package is often cited as the meme example of how bad JavaScript developers are. They install packages for everything. And it still to this day gets a million downloads a week. Notice how it's dipping. It's dipping because no one's going to write that again because nobody's going to install it when the Vibe coding will just write it for them or use the browser standard. The problem with having all these depths is that they abstract your ability to own and control your codebase and make changes. I can't tell you how many times we run into problems because something like the AISDK has an incorrect opinion and we have to go patch package it to fix it. That said, the work of writing our own alternative to the ASDK makes it worthwhile in that case. We weighed the benefits and negatives of each path and we chose to go down the path where we use the package instead of making our own alternative. Vibe coding and AI coding helps you do very similar things without having to bring in other people's code. If you vibe code the solution instead of installing it as a package, you still don't know how it works, you're still not reading the code the majority of the time. That all said, if you need to make a change to the thing you vibe coded, it's a hell of a lot easier than making a change to a package that you installed. The reasons that people don't like package installations are all, for the most part, solved with vibe coding. But they're mad at both because they're not good faith operators. They just want to be mad so they can feel like they're a better developer than you are. And this is the funniest part. I can't tell you how often I get [ __ ] for being a vibe coder and vibe coding all of T3 chat. I did not [ __ ] vibe code T3 Chat. Go try to do it yourself and you'll see just how hard it is to build we built there. No AI tool is going to build a fifth of what we have, much less get the [ __ ] markdown renderer working properly with all the weird syntax and [ __ ] Good luck. Have fun. Seriously, I'd love to see someone do it. You won't. I'm a top ranked Elite Code competitor. I come in the top 200 in Advent of Code every year. That's 200,000 people compete and I'm in the top 200 regularly. I'm not saying this to gloat. I don't talk about it very often. I have 800 plus videos and the fact that I'm a good coder has come up like five times. I just don't care. I think my work speaks for itself. So people who don't have any work that will speak for them love to talk [ __ ] on me because I make them insecure. Cool. Good for them. This video is for you. You're a bad person if you think this way. If you cannot understand that the solution to people having too many packages is to make it easier for them to write the package because they want this for two reasons. They want to solve their problem and they don't want to look at the details. Vibe coding gives them that and now they don't have the problem of an external dependency. If you cannot see how that solves the thing you're mad about then you're not being genuine with what you're mad about. You can't be mad at vibe coding and be mad at LaPad. I will stand behind that statement. Sorry for getting a bit heated at that part. To be very clear, I am just annoyed that when I and I noticed when this happened, when I hit 100,000 subscribers, it was like on that line. I went from the open- source developer and contributor that knows what they're doing, that happens to be a YouTuber, to the YouTuber who pretends he can write code. If you want to know if I'm good at code or not, and you've never talked with one of my co-workers or read my code, just shut the [ __ ] up. If you need me to be bad at code to feel better about your opinions, you should understand the fact that you're being bad faith. And if you can't understand that, just close the video, unsubscribe, leave. I'm trying to have a conversation, not a [ __ ] posting fest. Anyways, there's an article that I've been planning on covering for a video for a while. I'm very excited to go more in depth on this. Vibe coding is legacy code. The point is that you forget the code even exists. We already have a phrase for that, legacy code. I really, really like this phrasing. This is the point. The majority of code in a code base after it's been reviewed and merged once will never be looked at again, will never be touched again, and will quietly do what it's supposed to until it is forgotten about or deprecated quietly and then left in the codebase because nobody knew they could delete it. That is a significant portion of software development. Hot take number four, Vibe code is a type of legacy code. The actual outputs of Vibe coding are legacy code skipping steps. If you need to fix something in legacy code, you could go in and fix it, but no one does. We grab the sledgehammer and we rewrite that portion. Throwaway code is part of life. Whether or not you accept that up to you, but I think we all should accept that fact. There are very few things worth doing where a bit of throwaway code won't make it a little bit better. Just some stupid examples. If you're working on a new feature for a product, it might be worth sitting there and planning it all out the correct way and doing it right the first time. But the vast majority of the time, if you can throw together a shitty prototype with code that you'll never actually merge or let see the light of day just to put it in front of a user and see how they feel about it, that will save you so much trouble because you won't go waste all of the time building the good code when you're building the wrong thing. Good code has two important characteristics. It solves the right problem and it doesn't suck to read. People get way too focused on the second part and they often, if not always, ignore the first part. Vibe coding is not meant to affect the second part. Vibe coding is not meant to make your code better. If the code that you're writing via the agent in cursor is better than the code you would have written yourself, turn that [ __ ] off. It is hurting you. You need to be good enough to write the code yourself because the point of these tools isn't to go beyond your ability. It's not to be better than you. It's to be worse than you, but more of you. If right now you're leaning on these tools because you don't know how to solve the problem, you're [ __ ] But if you're using these because you know how to solve the problem and don't care enough to, then you're good. We'll put that as point five. If the tools are better than you, stop using them. Just straight up. If you have to use these to solve the problem because you don't know how to otherwise, you're screwed. So, one example of this in my current life, I accidentally got my whole team effect pilled because I knew that a lot of the weird async [ __ ] we were dealing with with upload thing in T3 chat could be much better if we had a better framework and set of tools for doing complex asynchronous work in Typescript. We have to do it in TypeScript. So, get out of here with your what about Rust [ __ ] I just don't want to talk about that right now. Effect allows us to do a much better job of building complex Asynchronous concurrent [ __ ] gets much easier with effect at the cost of having to relearn the language that you're writing. If you're not already an effect person, you're going to look at this code and your brain's going to fall out a bit. Program equals effect.gen function star transaction amount equals yieldstar fetch transaction amount. Not even calling it as a function. Discount rate equals yield star fetch discount rate. Discounted amount is yield star apply discount. Now we're passing the transaction the discount. final amount equals add service charge and you return that. Oh, they're already even wrapping it with an effect succeed. Yeah, if you don't already write effect, you're looking at this and your brain's falling out. And I understand. I still kind of feel that way. The reason I bring this up is because I use AI tools for writing code a lot. When I have to touch things that my team has rewritten in effect, I turn off the agent. I believe me, I have felt the temptation. I have heard the siren sing. Theo, you could contribute to these effect parts again if you just open up the agent and tell it what to do. And I don't fall for the siren because I know better. If I want to contribute to the effect parts of the codebase, I need to get [ __ ] good at effect. I don't get to code a lot nowadays because I'm busy. Hi. So, I haven't had the time to really sit down and learn effect because you have to you have to learn it. It's a different way of thinking. But as chat's calling out here, it's so hard to not fall for the siren call. Absolutely. And this is a thing I've talked about a lot in my content about AI. I have a lot of concerns for students that are learning. I have a lot of concerns for people who are trying to improve but are using these AI tools because people intuitively don't want to feel dumb. Feeling dumb sucks. Feeling blocked sucks. Feeling like you don't have the skill you need to solve the problem in front of you sucks. People don't like being blocked. And these AI tools promise that they can get you unblocked. You don't even need to understand it. You can just do it. And that's bad. That's where the danger lies when these tools trick you into thinking you don't have to know and give you the comfort of not knowing. You should never take comfort in not knowing. That's where the danger is. The magic of these tools isn't that they make it so you don't need to know how to code. The magic of these tools is that you can go have a bunch of random code that you didn't feel like writing to solve a bunch of random problems that would have just been left unsolved. It's a weird rabbit hole to go down, but this is why addiction happens because when you have the terrible, horrible feelings in yourself that come from withdrawal, you can power through it and become better on the other side, or you can do the thing you're addicted to and feel better immediately and not actually improve. In fact, you're making your life worse. That pattern is the thing that happens with a lot of people using these AI tools for writing code, for doing work and whatnot. That is dangerous. They should never go beyond your ability. If you use AI to learn things, cool. I've used GPT5 to learn a lot more about effect. I'll often go to T3 chat and say, "Hey, I'm learning about this feature in effect. Can you help me better understand this code?" I'm not outsourcing the knowledge. I'm outsourcing the question to learn the thing. But that's why when I'm touching effect code in my codebase, I turn off the agent, I open up T3 chat and I copy paste things over and ask questions because as soon as I have this sidebar open, the temptation isn't to ask it how it works. It's to tell it go fix the thing. So even I knowing what the [ __ ] I'm doing realize this and force myself to close the agent, read the code, and if I still don't understand it, copy paste it over to some chat tool and ask about it because the temptation will always be there to not learn. And what's really crazy to go back to this Reddit post, this is clearly a person who has been delaying learning how to code for a very long time. If they have been paying developers before and they thought vibe coding but they didn't have to pay devs anymore and now they're realizing they do. They've been doing this for long enough that they could have just sat down and learned how to [ __ ] code. Yeah, I have feelings. My one last hot take. If you don't see how vibe coding can help you, you aren't very creative. Or I'll go even further. Or maybe you're being dishonest. This is the part that frustrates me the most. I am genuinely so annoyed that there are developers who really know what they're doing, who are very smart, that refuse to accept the fact that there are problems they have in their life that are not big enough for them to sit there and write a bunch of code for, but are big enough that they annoy them every day and if someone was to hand them the solution, they would consider using it. I'll be frank, I didn't see a lot of these problems for myself initially. But over time, my brain's been rewired, and now I see more and more of these things. Here's a silly example. I deal with a lot of assets for my content. I deal with a lot of SVG files for logos for brands that we work with. SVG is a phenomenal format. I have a long video about it that's probably already out by now. But SVGs don't work in every program. In particular, they don't work in my video editing software. So, if I have an SVG logo from a company and I want to put it into my video that I'm editing, I can't. And I can open it up in graphics software, hit a whole bunch of hotkeys, manually type the resolution, export it, realize the aspect ratio was off, and then go do it again. And I was annoyed enough by this, and I noticed my team was too. So, I went and spent under an hour, probably 15 minutes, vibe coding an app that lets you upload an SVG and then turns it into a PNG. Here is a skateboard SVG. You can't see it very well cuz it's black. So, here it is by default 1200 x 1200. And now I can hit save as PNG. And now I have a PNG of that SVG at that resolution. If I want it higher res because it's an SVG, it's a vector. I could click 8x, save it. We're good. Surprise. My CTO has a good take on this. I had seen this. This is the reality of LM replacing engineers. They're just enabling the tailor made software for one to a few people that no engineer was ever going to build anyways. Less platforms, more personal software. It doesn't have to be good or scalable. It just has to solve the problem that a few people have and then it's worth it. This is Near Cyan made their homemade ETH sleep, which is a small fish tank cooler in mattress overlay. This is a vibecoded solution for keeping their bed cool. That's really cool. This would make no sense for them to sell or do anything with, but now they can build a solution to a thing that would not have been worth the effort before. with the SVG to PNG converter. There were some tools that could do parts of this. None of them had the right UX. Most of them charged money. A lot of them did it on the server, which made no sense. The way I'm doing it here is I render it in the canvas and when you save it, it just screenshots the canvas effectively using the canvas API. It's built to do this and it does it really well. There's no reason for a server to be involved at all. And I knew that cuz I know the browser. I knew how to write this. I could have written at any point in my life, but I didn't feel like it. I have other [ __ ] to do. So instead, I vibe coded it and had it done in an hour. And then I had other things I wanted. I wanted a square image generator. And this one's funny. This one's because YouTube doesn't crop previews on images properly when you post them in the community feed. So it's always better for your community posts to be a square, so it will actually fit properly on the page. So let's do my favorite thing when I want to be more popular on YouTube. We're going to go to programming humor. We're going to look at the top posts of the past month. Here's a good one. A friend learned Cobalt and received a codebase where the last change was done in the 90s by his mom. That's not how inheritance is supposed to work in programming. So, I've downloaded this image and if I post it on YouTube as is, it won't fit right. So, instead, we're going to upload this meme. We're going to choose black as the background color. I have saved it. And now I have the same exact image, but now it is a perfect square. And now when I go to YouTube to post this, I post the square version and it will fit in the feed properly. And with very little effort, I just made a post that will get a few thousand likes on YouTube that I wouldn't have made before because when I tried posting it and I saw that the text was cut off because YouTube's [ __ ] cropping is so broken, I would have deleted the post and not bothered. This is what vibe coding is good for. These are things I could have written. It's not doing a thing I can't do. It is helping me do a thing I didn't feel like doing to solve a problem I was annoyed about. As I said here, I built these tools because I was annoyed that they did not exist. And if you don't have anything that falls in that category, you're not thinking hard enough or you're just not being honest with yourself because there are so many of these types of things in the world. And I find so many of those throughout my life. Now that I'm thinking this way, I find them all the time. I'm like, "Oh, I want this information. I'm going to go write a script to generate it for me. When I did the puzzles at Defcon this year, I probably vibe coded 5 to 10,000 lines of code to try and create various solutions to the problems that we were trying to solve. I could have handwritten the code, but my process would have been very different. I would have went out of my way to prove that the solution was correct before I bothered writing the code. And this is probably the hottest and biggest take I have here. Vibe code is great because throwing it away never hurts. Engineers get so attached to their code. If you're one of the people raging in my comment section right now, you're probably one of those people because you like the code you write a lot. It hurts you a lot when you have to get rid of it when it doesn't solve the problem, right? Or it's being replaced with something else. I'm weird because I like when my code is replaced. That means there's something better. Maybe I don't think it's better, but it's better enough that it's being replaced. It might end up being worse and it gets swapped back. Whatever. Either things will be learned or things are better. There's always one or the other. I don't mind when my code is thrown away, but most people do. Because of that, there are two problems. The first problem is that there's code that should be thrown away, but because of developers having emotional attachment to it, it won't be. But the bigger problem, the one I see more of, is the second one. There is code that they would write because it's useful, but they don't because they know it's not useful enough to stick around and it will be thrown away. This is what I'm excited about with vibe coding. There is code that I wouldn't have written because it wouldn't have been useful enough and I would have felt bad when it didn't ship or got tossed or whatever else. I would say half or more of my PRs either get left open or get closed without merging because I'm not writing those PRs to expect every single line of code I write to merge and be how we do things. The only person who's deleted more of my code than Mark is me. I love getting rid of my code and replacing it with other [ __ ] because it's less to deal with. Most people aren't like that. And even though I am like that, I still hesitate and find myself not willing to sit there and do the thing if I'm fearful of it not being useful, not being used, or being tossed out. Now I feel the opposite where I'm excited to go try and solve the problem, especially if I can do it with command I. Yeah, last hot take here. Anyone told that vibe code means you don't need devs was lied to. This is a very, very important point. I want to make sure it's not lost in the weeds of me defending vibe coding as a way for us to be more productive and build things that we wouldn't have otherwise. Vibe coding very explicitly does not mean you don't need to know how to code. A lot of people were sold this. They were all lied to. They should be angry and we should make fun of the people who keep saying this. I don't believe this future will ever exist. Imagine if when we started getting better technology for running farms that the response to that was, well, everyone's going to be a farmer now. You don't need professional farmers anymore. No, it was actually the opposite. There are now way fewer farmers that are deeper experts in their field that are generating solutions, in this case food, for larger numbers of people. If previously a farmer could make food for up to 10 people, new technologies made it so that farmer could make food for hundreds of thousands of people instead. That doesn't mean there are more farmers. It does kind of mean you don't have to know how to grow food. But that's not cuz you're going to go grow your food yourself using these new tools. It's because the tools have improved so much that the people using them who understand them and understand all sides can be more productive with the work they do. Thank you all for coming to my vibe coding manifesto. Sorry for the angry rant about this one. I'm just so frustrated with all sides of this. The AI bros who say that everyone will be coders, they annoy the [ __ ] out of me. And the super elite developers who say AI tools are useless, they annoy me even more. Both sides here are wrong. And it's because they don't understand the terms and they don't see the value of being able to generate code that you don't actually care enough about to read. I'll say what I have to say here. I hope this is useful to somebody. Let me know what y'all think.