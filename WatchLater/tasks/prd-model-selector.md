# Model Selector Dropdown

## Introduction / Overview
Power users want to compare summaries generated by different large language models, including Gemini and OpenRouter-backed models, without leaving the WatchLater UI. This feature adds a persistent model selector beside the existing summary action buttons so users can choose which provider/model powers the next transcript summarization.

## Goals
- Allow users to switch between configured model identifiers at any time from the main workspace.
- Ensure the chosen model is honored for the next summary run (including manual refresh).
- Keep the configuration flexible by defining defaults and available models via environment variables.

## User Stories
- As a power user, I want to pick a different summarization model so I can compare output quality for the same video.
- As a researcher, I want the UI to remember the last model I selected during the session so iterative runs stay consistent.
- As a developer, I want to control which models appear in the selector through environment variables so I can add/remove providers without code changes.

## Functional Requirements
1. The UI must render a gradient-purple model selector control alongside the existing download, PDF, copy, refresh, and folder buttons in the summary action bar.
2. The selector must display the default model (from env) on first load and update its label immediately when the user chooses a different option.
3. Selecting a model updates in-memory state so that the next summarize pipeline invocation (initial run or refresh) uses the chosen model identifier.
4. The selector must be populated from an environment-driven list (e.g., comma-separated models with optional display labels).
5. The active model choice should persist for the current browser session (e.g., via state or session storage) but can reset on full page reload.
6. The selected model identifier must be included in backend requests responsible for generating summaries so the server can route to the requested provider.
7. If an unconfigured model is somehow selected (e.g., env mismatch), the system must fall back to the default model and surface a console warning.
8. Provide lightweight validation to ensure at least the default model exists and is present in the option list at startup; show a toast/banner if configuration is invalid.

## Non-Goals
- Implementing new backend routing logic for additional providers beyond passing the chosen identifier downstream.
- Persisting model preferences to disk or across devices.
- Surfacing per-model documentation or advanced settings in the selector.

## Design Considerations
- Selector styling: compact pill/segmented control with gradient purple background to match existing UI accents.
- Placement: right-aligned within the summary action toolbar, directly before the refresh button for quick access.
- Accessibility: keyboard navigable, clearly labeled (e.g., "Model"), with focus states and sufficient contrast.

## Technical Considerations
- Introduce env vars such as `VITE_MODEL_DEFAULT` (single value) and `VITE_MODEL_OPTIONS` (comma-separated list of `id|Label` pairs) consumed by the Vite client; default to Gemini if unset.
- Consider passing the selected model via existing API methods (e.g., extend `generateSummaryFromFile` payload) and ensure server-side logging includes the model id for observability.
- Add a thin model registry utility to parse env values once, cache results, and provide helpers for validation.

## Success Metrics
- ≥80% of power users report the selector meets their comparison needs in dogfooding feedback.
- ≥50% of summary runs during testing exercises use a non-default model, indicating discoverability.
- No increase in “wrong model” support tickets after launch.

## Open Questions
- Should we surface provider grouping (e.g., Gemini vs OpenRouter) or keep the flat list?
- Do we need per-model tooltips (latency/cost) or is the label sufficient?
- Should the selector choice persist beyond the session via localStorage or user profile once authentication exists?

# Tasks

## Relevant Files

- `.env.example` - Document new `VITE_MODEL_DEFAULT` and `VITE_MODEL_OPTIONS` variables for local setup.
- `README.md` - Explain how to configure model defaults and option list for the selector.
- `SECURITY.md` - Note multi-provider considerations for keeping API keys private.
- `src/config/model-registry.ts` - Parse environment-driven model options and expose defaults/warnings.
- `src/api.ts` - Include the selected model identifier in summary-related API calls.
- `src/App.tsx` - Manage model selection state and wire the selector into the action toolbar.
- `src/App.css` - Add styling for the gradient-purple selector control.
- `src/components/ModelSelector.tsx` - Encapsulate the selector UI and accessibility behavior.
- `src/context/model-context.tsx` - Provide React context/hooks for accessing the active model.
- `server.js` - Proxies OpenRouter requests and persists model metadata in saved summaries.
- `tests/model-registry.test.ts` - Unit tests covering env parsing and default fallback logic.
- `tests/api-model-selection.test.ts` - Verify client requests include the active model id.
- `tsconfig.test.json` - Ensure Jest compiles modules with import.meta compatibility.

### Notes

- Unit tests should typically be placed alongside the code files they are testing (e.g., `MyComponent.tsx` and `MyComponent.test.tsx` in the same directory).
- Use `npx jest [optional/path/to/test/file]` to run tests. Running without a path executes all tests found by the Jest configuration.

## Tasks

- [x] 1.0 Define environment-driven model configuration
  - [x] 1.1 Add `VITE_MODEL_DEFAULT` and `VITE_MODEL_OPTIONS` to `.env.example` and describe usage in `README.md`.
  - [x] 1.2 Implement a model registry helper that parses env-provided options, trims whitespace, and exposes the default/available models.
  - [x] 1.3 Validate on startup that the default exists in the option list; log warnings or surface UI feedback when misconfigured.
- [x] 2.0 Add client-side model registry state management
  - [x] 2.1 Initialize selected-model state from the registry default when the app loads.
  - [x] 2.2 Persist the user’s choice for the current session (e.g., sessionStorage) and rehydrate on refresh within the session.
  - [x] 2.3 Expose hooks/utilities for retrieving and updating the active model across components.
- [x] 3.0 Implement summary toolbar model selector UI
  - [x] 3.1 Create the `ModelSelector` component with gradient-purple styling, accessible labeling, and keyboard support.
  - [x] 3.2 Place the selector beside the existing action buttons (before refresh) and ensure layout responsiveness.
  - [x] 3.3 Display the selected model label, including provider hints when provided in env labels.
- [x] 4.0 Pass the active model through the summarize pipeline
  - [x] 4.1 Update client API calls (`generateSummary`, `generateSummaryFromFile`, refresh flow) to include the active model identifier.
  - [x] 4.2 Adjust server handlers to accept the model parameter, log it, and forward it to downstream services as needed.
  - [x] 4.3 Ensure the refresh/regenerate button reuses the currently selected model without resetting to default.
- [x] 5.0 Validate configuration, add tests, and update docs
  - [x] 5.1 Add unit tests for the model registry helper covering parsing, default selection, and error states.
  - [x] 5.2 Add client tests (unit or integration) verifying requests include the selected model and fallback behavior works.
  - [x] 5.3 Update docs (README, SECURITY/FAQs) to explain multi-model support and configuration controls.
